from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

# ------------------------------
# Data Models (Pydantic)
# ------------------------------

class UserProfile(BaseModel):
    userId: str
    healthGoals: List[str]
    dietaryRestrictions: List[str]
    preferences: dict  # e.g., {"favorite_cuisine": "Italian", "disliked_ingredients": ["olives"]}
    exerciseRoutine: str = "Moderate" # Example: "3 times per week"
    #Add more fields as necessary (weight, age, etc.)

class MealPlan(BaseModel):
    meals: List[dict] #Each dict represents a meal (name, ingredients, recipe, nutrition info)

class GroceryItem(BaseModel):
    name: str
    quantity: str #e.g., "2", "1 kg", "1 bunch"
    category: str #e.g., "Produce", "Dairy", "Meat"

class GroceryList(BaseModel):
    items: List[GroceryItem]


# ------------------------------
# In-Memory Data (for demonstration only - replace with database access later)
# ------------------------------

# This simulates a database for the MVP phase.  In later phases, we'll connect to Cloud SQL and Firestore
users = {} # User data stored in-memory (e.g. users[user_id] = UserProfile object)

# ------------------------------
# API Endpoints
# ------------------------------

# 1. User Authentication (Basic - for MVP.  Improve in later phases with OAuth/JWT)
# In a real application, you'd have a more robust authentication system.
@app.post("/login/{user_id}")
async def login(user_id: str):
    # In a real app, you would verify username/password
    # Here, we just create a user if they don't exist (for simplicity in the MVP)
    if user_id not in users:
        users[user_id] = UserProfile(userId=user_id, healthGoals=[], dietaryRestrictions=[], preferences={})
    return {"message": f"Logged in as user {user_id}"}


# 2. Get User Profile
@app.get("/users/{user_id}", response_model=UserProfile)
async def get_user_profile(user_id: str):
    if user_id not in users:
        raise HTTPException(status_code=404, detail="User not found")
    return users[user_id]


# 3. Update User Profile
@app.put("/users/{user_id}", response_model=UserProfile)
async def update_user_profile(user_id: str, user_profile: UserProfile):
    if user_id not in users:
        raise HTTPException(status_code=404, detail="User not found")
    # In a real application, you'd validate the incoming data.
    users[user_id] = user_profile
    return user_profile


# 4. Request Meal Plan
@app.post("/meal_plan/{user_id}", response_model=MealPlan)
async def request_meal_plan(user_id: str):
    # In a real application, you would pass this request to the Meal Planning AI.
    # For the MVP, we'll return a hardcoded meal plan.
    if user_id not in users:
        raise HTTPException(status_code=404, detail="User not found")

    sample_meal_plan = MealPlan(meals=[
        {"name": "Breakfast: Oatmeal with berries", "ingredients": ["oatmeal", "berries", "milk"], "recipe": "Mix ingredients and cook", "nutrition": {"calories": 300}},
        {"name": "Lunch: Salad with grilled chicken", "ingredients": ["salad", "chicken", "dressing"], "recipe": "Assemble salad", "nutrition": {"calories": 400}},
        {"name": "Dinner: Salmon with vegetables", "ingredients": ["salmon", "vegetables"], "recipe": "Bake salmon and steam vegetables", "nutrition": {"calories": 500}}
    ])
    return sample_meal_plan


# 5. Get Grocery List
@app.get("/grocery_list/{user_id}", response_model=GroceryList)
async def get_grocery_list(user_id: str):
    #In a real application, this will be generated by the Grocery Management AI, based on the Meal Plan
     if user_id not in users:
        raise HTTPException(status_code=404, detail="User not found")

     sample_grocery_list = GroceryList(items=[
        GroceryItem(name="Oatmeal", quantity="1 bag", category="Grains"),
        GroceryItem(name="Berries", quantity="1 punnet", category="Produce"),
        GroceryItem(name="Chicken Breast", quantity="500g", category="Meat")
    ])
     return sample_grocery_list

# ------------------------------
# Basic Root Endpoint (Kept from the previous example)
# ------------------------------

@app.get("/")
async def read_root():
    return {"message": "FastAPI API - Jackie Health"}